# Задача

Необходимо написать in-memory кэш, который будет по ключу (`UUID` пользователя) возвращать профиль и список его заказов.

1. У кэша должен быть `TTL(N-секунд)`
2. Кэшем может пользоваться функция(-и), которая работает с заказами (добавляет/обновляет/удаляет). Если `TTL` кэша истек, то возвращается `NULL` значение. При обновлении `TTL` снова устанавливается `N-сек`. Методы должны быть потокобезопасными.
3. Должны быть написаны тестовые сценарии использования данного кэша (базовые структуры менять нельзя).

**Дополнительное задание:** Реализовать автоматическую очистку истекших записей кэша.

## Базовые структуры
Базовая структура объекта `Order`

    type  Order  struct {
	    UUID  string
	    Value  interface{}
	    CreatedAt  time.Time
	    UpdatedAt  time.Time
    }

Базовая структура объекта `Profile`

    type  Profile  struct {
	    UUID  string
	    Name  string
	    Orders []*Order
    }

## Добавление в кэш-хранилище

    /*
    * Функция получения значения кэша по уникальному идентификатору `UUID`
    */
    func (cache *Cache) Get(UUID  string) (*Profile, bool) {
	    // На время действия функции получения значения
	    // блокируем мьютекс на чтение кэш-хранилища
	    cache.mutex.RLock()

	    // При завершении функции получения значения снимаем
	    // блокировку с мьютекса на чтения хранилища
	    defer  cache.mutex.RUnlock()
    
        item, ok := cache.data[UUID]
	    
	    if !ok {
		    return  nil, false
	    }
    
	    // В случае если значение кэша просрочено возвращаем нулевое значение
	    if  time.Now().After(item.expireAt) {
		    return  nil, false
	    }   
    
	    return  item.profile, true
    }
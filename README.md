# Задача

Необходимо написать in-memory кэш, который будет по ключу (`UUID` пользователя) возвращать профиль и список его заказов.

1. У кэша должен быть `TTL(N-секунд)`
2. Кэшем может пользоваться функция(-и), которая работает с заказами (добавляет/обновляет/удаляет). Если `TTL` кэша истек, то возвращается `NULL` значение. При обновлении `TTL` снова устанавливается `N-сек`. Методы должны быть потокобезопасными.
3. Должны быть написаны тестовые сценарии использования данного кэша (базовые структуры менять нельзя).

**Дополнительное задание:** Реализовать автоматическую очистку истекших записей кэша.

## Базовые структуры
Базовая структура объекта `Order`

    type  Order  struct {
	    UUID  string
	    Value  interface{}
	    CreatedAt  time.Time
	    UpdatedAt  time.Time
    }

Базовая структура объекта `Profile`

    type  Profile  struct {
	    UUID  string
	    Name  string
	    Orders []*Order
    }

## Получения значения из кэша
Метод получает уникальный идентификатор `UUID` и в потокобезопасном режиме при блокировке `RWMutex` проверяет наличие в кэш-хранилище наличие элемента. В случае если элемент был найден, возвращает `Profile` и `true`, в ином случае будут возвращены значения `nil`, `false`
	
    func (cache *Cache) Get(UUID  string) (*Profile, bool) {
	    // На время действия функции получения значения
	    // блокируем мьютекс на чтение кэш-хранилища
	    cache.mutex.RLock()

	    // При завершении функции получения значения снимаем
	    // блокировку с мьютекса на чтения хранилища
	    defer  cache.mutex.RUnlock()
    
        item, ok := cache.data[UUID]
	    
	    if !ok {
		    return  nil, false
	    }
    
	    // В случае если значение кэша просрочено возвращаем нулевое значение
	    if  time.Now().After(item.expireAt) {
		    return  nil, false
	    }   
    
	    return  item.profile, true
    }

## Добавление значения в кэш
Метод получает указатель на значение `Profile` и в потокобезопасном режиме при блокировке `RWMutex` добавляет значение в кэш-хранилище. При это метод передает сущности обновленное значение `expireAt`

    func (cache *Cache) Set(profile *Profile) {
	    // На время действия функции записи значения
	    // блокируем мьютекс на запись в кэш-хранилище
	    cache.mutex.Lock()
	    
	    // При завершении функции снимаем блокировку с мьютекса
	    // на запись значений в кэш-хранилище
	    defer  cache.mutex.Unlock()
	    
	    // Устанавливаем/обновляем время истечения кэша 
	    expireAt := time.Now().Add(cache.ttl)      
    
	    cache.data[profile.UUID] = &CacheItem{
		    profile: profile,
		    expireAt: expireAt,
	    }
    }

## Автоматическая очистка кэш-хранилища 
Сборщик мусора активируется в функции-конструкторе при создании кэш-хранилища. Интервал прохода сборщика равен `time.Minute`. В данном случае каждую минуту сборщик с помощью функции удаления значений из кэша `cleanCacheItems()` очищает кэш-хранилище 

    func (cache *Cache) GarbageCollector() {
	    // Запускаем сборщик мусора, который срабатывает каждые N-секунд
	    // по интервалу и удаляет значения из кэш-хранилища. В данном случае интервал
	    // срабатывает каждую минуту. Чем больше интервал по очистке хранилища, тем больше памяти оно начинает занимать
	    ticker := time.NewTicker(time.Minute)
	    
	    // При завершении очистки закрываем интервал
	    defer  ticker.Stop()
	    
	    for {
		    select {
			    case <-ticker.C:
				    cleanCacheItems(cache)
		    }
	    }
    }

### Функция удаления значений из кэш-хранилища
В целях оптимизации первый цикл под заблокированным `RWMutex` собирает и передает идентификаторы просроченных значений кэша в срез  `expiredCacheItemIds`. После данной операции происходит снятие блокировки на чтение и смена на блокировку записи. В конечной операции внутри цикла происходит финальное удаление записей кэша из хранилища и снятие блокировки c `RWMutex`. 

Данный подход позволяет оптимизировать процесс удаления благодаря тому, что мы собираем значения просроченных значений давая другим тредам возможность параллельно читать значения из кэш-хранилища.

    func  cleanCacheItems(cache *Cache) {
	    // До момента сбора идентификаторов протухших кэш-значений блокируем мьютекс на чтение
	    // из кэш-хранилища, поскольку может возникнуть конфликт при прочтении удаляемого значения
	    cache.mutex.RLock()
	    
	      // При завершении выполении функции снимаем блокировку с мьютекса и разрешаем
	    // запись и создание новых кэш-значений
	    defer  cache.mutex.Unlock()
	    
	    // Срез идентификаторов истекших по времени кэш-значений.
	    expiredCacheItemIds := make([]string, len(cache.data))
	    
	    // В данном цикле исключительно ищем истекшие по времени хэш-значения и
	    // помещаем и в срез для последующего удаления
	    for  id, item := range  cache.data {
		    isCacheItemExpired := time.Now().After(item.expireAt)
		    		    
		    if  isCacheItemExpired {
			    expiredCacheItemIds = append(expiredCacheItemIds, id)
		    }
	    }
	    
	    // Снимаем блокировку мьютекса после сбора всех идентификаторов протухших
	    // кэш-значений и обновляем его на чтение до момента удаления всех собранных кэшей
	    cache.mutex.RUnlock()
	    cache.mutex.Lock()
        
	    // Удаляем из кэша все истекшие по времени значения
	    for  _, id := range  expiredCacheItemIds {
		    delete(cache.data, id)
	    }
    }

## Конструктор `Cache`
При создании экземпляра кэш-хранилища возвращаем указатель на сущность и запускаем фоновый процесс сборщика мусора.

    func  New(ttl  time.Duration) *Cache {
	    cache := &Cache{
		    data: make(map[string]*CacheItem),
		    ttl: ttl,
		    mutex: sync.RWMutex{},
	    }
	    
	    go  cache.GarbageCollector()

	    return  cache
    }
